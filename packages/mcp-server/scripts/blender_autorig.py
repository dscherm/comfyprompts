"""Blender Python script for auto-rigging 3D models.

This script creates armatures/skeletons for 3D models generated by ComfyUI.
It supports various rig types for animation.

Usage (called by external_app_manager.py):
    blender --python blender_autorig.py -- <asset_path> <rig_type> [options_json]

Rig Types:
    humanoid: Full humanoid rig using Rigify (best for characters)
    quadruped: Four-legged animal rig
    simple: Basic spine/limb rig
    biped_simple: Simplified two-legged rig
    custom: Custom bone chain based on options

Options (JSON):
    {
        "auto_weights": true,        # Auto-assign vertex weights
        "symmetrize": true,          # Make rig symmetrical
        "bone_size": 0.1,            # Bone display size
        "generate_ik": true,         # Add IK constraints
        "output_path": "path.blend"  # Save to file (optional)
    }
"""

import sys
import os
import json
import math
from pathlib import Path

try:
    import bpy
    import mathutils
    from mathutils import Vector, Matrix
except ImportError:
    print("ERROR: This script must be run from within Blender")
    sys.exit(1)


# ==================== UTILITY FUNCTIONS ====================

def clear_scene():
    """Clear default objects from scene."""
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete(use_global=False)


def get_mesh_bounds(obj):
    """Get bounding box of a mesh object in world space."""
    if obj.type != 'MESH':
        return None

    bbox = [obj.matrix_world @ Vector(corner) for corner in obj.bound_box]

    min_co = Vector((min(v.x for v in bbox), min(v.y for v in bbox), min(v.z for v in bbox)))
    max_co = Vector((max(v.x for v in bbox), max(v.y for v in bbox), max(v.z for v in bbox)))
    center = (min_co + max_co) / 2
    size = max_co - min_co

    return {
        "min": min_co,
        "max": max_co,
        "center": center,
        "size": size,
        "height": size.z,
        "width": size.x,
        "depth": size.y
    }


def find_mesh_objects():
    """Find all mesh objects in the scene."""
    return [obj for obj in bpy.data.objects if obj.type == 'MESH']


def import_asset(filepath):
    """Import a 3D asset file."""
    ext = Path(filepath).suffix.lower()

    if ext in [".glb", ".gltf"]:
        bpy.ops.import_scene.gltf(filepath=filepath)
    elif ext == ".fbx":
        bpy.ops.import_scene.fbx(filepath=filepath)
    elif ext == ".obj":
        bpy.ops.wm.obj_import(filepath=filepath)
    else:
        raise ValueError(f"Unsupported format: {ext}")

    return find_mesh_objects()


# ==================== ARMATURE CREATION ====================

def create_armature(name="Armature"):
    """Create a new armature object."""
    armature_data = bpy.data.armatures.new(name)
    armature_obj = bpy.data.objects.new(name, armature_data)
    bpy.context.collection.objects.link(armature_obj)
    return armature_obj


def add_bone(armature_obj, name, head, tail, parent_name=None, connect=False):
    """Add a bone to an armature.

    Must be in edit mode on the armature.
    """
    bone = armature_obj.data.edit_bones.new(name)
    bone.head = head
    bone.tail = tail

    if parent_name:
        parent = armature_obj.data.edit_bones.get(parent_name)
        if parent:
            bone.parent = parent
            bone.use_connect = connect

    return bone


def enter_edit_mode(armature_obj):
    """Enter edit mode on armature."""
    bpy.context.view_layer.objects.active = armature_obj
    bpy.ops.object.mode_set(mode='EDIT')


def exit_edit_mode():
    """Exit edit mode."""
    bpy.ops.object.mode_set(mode='OBJECT')


# ==================== RIG TYPES ====================

def create_humanoid_rig(mesh_obj, options):
    """Create a humanoid rig using Rigify metarig.

    This creates a full humanoid skeleton suitable for character animation.
    """
    bounds = get_mesh_bounds(mesh_obj)
    if not bounds:
        return None

    height = bounds["height"]
    center = bounds["center"]
    base_z = bounds["min"].z

    # Try to use Rigify if available
    try:
        # Enable Rigify addon
        if "rigify" not in bpy.context.preferences.addons:
            bpy.ops.preferences.addon_enable(module="rigify")

        # Add Rigify human metarig
        bpy.ops.object.armature_human_metarig_add()
        armature = bpy.context.active_object

        # Scale and position metarig to fit model
        armature.location = (center.x, center.y, base_z)

        # Scale metarig to match model height (metarig is ~2 units tall)
        scale_factor = height / 2.0
        armature.scale = (scale_factor, scale_factor, scale_factor)
        bpy.ops.object.transform_apply(scale=True)

        armature.name = "Humanoid_Rig"

        # Generate the actual rig from metarig
        bpy.context.view_layer.objects.active = armature
        try:
            bpy.ops.pose.rigify_generate()
            # Find the generated rig
            generated_rig = bpy.data.objects.get("rig")
            if generated_rig:
                armature = generated_rig
        except Exception as e:
            print(f"Rigify generate failed (metarig still usable): {e}")

        return armature

    except Exception as e:
        print(f"Rigify not available, falling back to manual humanoid rig: {e}")
        return create_biped_simple_rig(mesh_obj, options)


def create_biped_simple_rig(mesh_obj, options):
    """Create a simplified biped rig without Rigify.

    Creates: spine, head, arms, legs with basic bone structure.
    """
    bounds = get_mesh_bounds(mesh_obj)
    if not bounds:
        return None

    height = bounds["height"]
    center = bounds["center"]
    base_z = bounds["min"].z
    width = bounds["width"]

    # Proportions (relative to height)
    hip_height = height * 0.5
    chest_height = height * 0.7
    neck_height = height * 0.85
    head_height = height * 0.95
    shoulder_width = width * 0.4
    hip_width = width * 0.15
    arm_length = height * 0.35
    leg_length = height * 0.45

    armature = create_armature("Biped_Rig")
    enter_edit_mode(armature)

    # Spine chain
    add_bone(armature, "root",
             (center.x, center.y, base_z),
             (center.x, center.y, base_z + height * 0.1))

    add_bone(armature, "spine",
             (center.x, center.y, base_z + hip_height * 0.5),
             (center.x, center.y, base_z + hip_height),
             parent_name="root")

    add_bone(armature, "spine.001",
             (center.x, center.y, base_z + hip_height),
             (center.x, center.y, base_z + chest_height),
             parent_name="spine", connect=True)

    add_bone(armature, "spine.002",
             (center.x, center.y, base_z + chest_height),
             (center.x, center.y, base_z + neck_height),
             parent_name="spine.001", connect=True)

    add_bone(armature, "neck",
             (center.x, center.y, base_z + neck_height),
             (center.x, center.y, base_z + head_height * 0.95),
             parent_name="spine.002", connect=True)

    add_bone(armature, "head",
             (center.x, center.y, base_z + head_height * 0.95),
             (center.x, center.y, base_z + height),
             parent_name="neck", connect=True)

    # Left arm
    shoulder_l = (center.x + shoulder_width, center.y, base_z + neck_height)
    elbow_l = (center.x + shoulder_width + arm_length * 0.5, center.y, base_z + neck_height - height * 0.05)
    wrist_l = (center.x + shoulder_width + arm_length, center.y, base_z + neck_height - height * 0.1)

    add_bone(armature, "shoulder.L",
             (center.x, center.y, base_z + neck_height),
             shoulder_l,
             parent_name="spine.002")

    add_bone(armature, "upper_arm.L", shoulder_l, elbow_l, parent_name="shoulder.L", connect=True)
    add_bone(armature, "forearm.L", elbow_l, wrist_l, parent_name="upper_arm.L", connect=True)
    add_bone(armature, "hand.L", wrist_l,
             (wrist_l[0] + arm_length * 0.15, wrist_l[1], wrist_l[2]),
             parent_name="forearm.L", connect=True)

    # Right arm (mirrored)
    shoulder_r = (center.x - shoulder_width, center.y, base_z + neck_height)
    elbow_r = (center.x - shoulder_width - arm_length * 0.5, center.y, base_z + neck_height - height * 0.05)
    wrist_r = (center.x - shoulder_width - arm_length, center.y, base_z + neck_height - height * 0.1)

    add_bone(armature, "shoulder.R",
             (center.x, center.y, base_z + neck_height),
             shoulder_r,
             parent_name="spine.002")

    add_bone(armature, "upper_arm.R", shoulder_r, elbow_r, parent_name="shoulder.R", connect=True)
    add_bone(armature, "forearm.R", elbow_r, wrist_r, parent_name="upper_arm.R", connect=True)
    add_bone(armature, "hand.R", wrist_r,
             (wrist_r[0] - arm_length * 0.15, wrist_r[1], wrist_r[2]),
             parent_name="forearm.R", connect=True)

    # Left leg
    hip_l = (center.x + hip_width, center.y, base_z + hip_height * 0.5)
    knee_l = (center.x + hip_width, center.y + height * 0.02, base_z + leg_length * 0.5)
    ankle_l = (center.x + hip_width, center.y, base_z + height * 0.05)

    add_bone(armature, "thigh.L", hip_l, knee_l, parent_name="spine")
    add_bone(armature, "shin.L", knee_l, ankle_l, parent_name="thigh.L", connect=True)
    add_bone(armature, "foot.L", ankle_l,
             (ankle_l[0], ankle_l[1] - height * 0.1, ankle_l[2]),
             parent_name="shin.L", connect=True)

    # Right leg (mirrored)
    hip_r = (center.x - hip_width, center.y, base_z + hip_height * 0.5)
    knee_r = (center.x - hip_width, center.y + height * 0.02, base_z + leg_length * 0.5)
    ankle_r = (center.x - hip_width, center.y, base_z + height * 0.05)

    add_bone(armature, "thigh.R", hip_r, knee_r, parent_name="spine")
    add_bone(armature, "shin.R", knee_r, ankle_r, parent_name="thigh.R", connect=True)
    add_bone(armature, "foot.R", ankle_r,
             (ankle_r[0], ankle_r[1] - height * 0.1, ankle_r[2]),
             parent_name="shin.R", connect=True)

    exit_edit_mode()

    # Add IK if requested
    if options.get("generate_ik", True):
        add_basic_ik(armature)

    return armature


def create_quadruped_rig(mesh_obj, options):
    """Create a quadruped (4-legged) rig for animals."""
    bounds = get_mesh_bounds(mesh_obj)
    if not bounds:
        return None

    height = bounds["height"]
    length = bounds["depth"]  # Y axis is typically length for quadrupeds
    width = bounds["width"]
    center = bounds["center"]
    base_z = bounds["min"].z

    armature = create_armature("Quadruped_Rig")
    enter_edit_mode(armature)

    # Spine runs along Y axis
    spine_y_start = center.y - length * 0.4
    spine_y_end = center.y + length * 0.35
    spine_z = base_z + height * 0.7

    # Root
    add_bone(armature, "root",
             (center.x, center.y, base_z),
             (center.x, center.y, base_z + height * 0.3))

    # Spine chain (front to back)
    add_bone(armature, "spine",
             (center.x, spine_y_start, spine_z),
             (center.x, center.y - length * 0.1, spine_z),
             parent_name="root")

    add_bone(armature, "spine.001",
             (center.x, center.y - length * 0.1, spine_z),
             (center.x, center.y + length * 0.1, spine_z),
             parent_name="spine", connect=True)

    add_bone(armature, "spine.002",
             (center.x, center.y + length * 0.1, spine_z),
             (center.x, spine_y_end, spine_z),
             parent_name="spine.001", connect=True)

    # Neck and head
    neck_start = (center.x, spine_y_end, spine_z)
    neck_end = (center.x, spine_y_end + length * 0.15, spine_z + height * 0.2)
    head_end = (center.x, spine_y_end + length * 0.3, spine_z + height * 0.25)

    add_bone(armature, "neck", neck_start, neck_end, parent_name="spine.002", connect=True)
    add_bone(armature, "head", neck_end, head_end, parent_name="neck", connect=True)

    # Tail
    tail_start = (center.x, spine_y_start, spine_z)
    add_bone(armature, "tail",
             tail_start,
             (center.x, spine_y_start - length * 0.15, spine_z - height * 0.1),
             parent_name="spine")
    add_bone(armature, "tail.001",
             (center.x, spine_y_start - length * 0.15, spine_z - height * 0.1),
             (center.x, spine_y_start - length * 0.3, spine_z - height * 0.2),
             parent_name="tail", connect=True)

    # Front legs
    leg_width = width * 0.3
    front_y = spine_y_end - length * 0.1
    back_y = spine_y_start + length * 0.1

    for side, x_offset in [(".L", leg_width), (".R", -leg_width)]:
        # Front leg
        shoulder = (center.x + x_offset, front_y, spine_z)
        elbow = (center.x + x_offset, front_y, spine_z - height * 0.35)
        paw_front = (center.x + x_offset, front_y, base_z + height * 0.05)

        add_bone(armature, f"front_upper{side}", shoulder, elbow, parent_name="spine.002")
        add_bone(armature, f"front_lower{side}", elbow, paw_front, parent_name=f"front_upper{side}", connect=True)
        add_bone(armature, f"front_paw{side}", paw_front,
                 (paw_front[0], paw_front[1] + length * 0.05, paw_front[2]),
                 parent_name=f"front_lower{side}", connect=True)

        # Back leg
        hip = (center.x + x_offset, back_y, spine_z)
        knee = (center.x + x_offset, back_y - length * 0.05, spine_z - height * 0.35)
        paw_back = (center.x + x_offset, back_y, base_z + height * 0.05)

        add_bone(armature, f"back_upper{side}", hip, knee, parent_name="spine")
        add_bone(armature, f"back_lower{side}", knee, paw_back, parent_name=f"back_upper{side}", connect=True)
        add_bone(armature, f"back_paw{side}", paw_back,
                 (paw_back[0], paw_back[1] + length * 0.05, paw_back[2]),
                 parent_name=f"back_lower{side}", connect=True)

    exit_edit_mode()
    return armature


def create_simple_rig(mesh_obj, options):
    """Create a simple spine-only rig for basic animations."""
    bounds = get_mesh_bounds(mesh_obj)
    if not bounds:
        return None

    height = bounds["height"]
    center = bounds["center"]
    base_z = bounds["min"].z

    num_bones = options.get("num_bones", 5)
    bone_height = height / num_bones

    armature = create_armature("Simple_Rig")
    enter_edit_mode(armature)

    # Create spine chain
    for i in range(num_bones):
        bone_name = f"bone.{i:03d}" if i > 0 else "root"
        parent_name = f"bone.{i-1:03d}" if i > 1 else ("root" if i > 0 else None)

        head_z = base_z + (i * bone_height)
        tail_z = base_z + ((i + 1) * bone_height)

        add_bone(armature, bone_name,
                 (center.x, center.y, head_z),
                 (center.x, center.y, tail_z),
                 parent_name=parent_name,
                 connect=(i > 0))

    exit_edit_mode()
    return armature


def create_custom_rig(mesh_obj, options):
    """Create a custom rig based on provided bone definitions."""
    bounds = get_mesh_bounds(mesh_obj)
    if not bounds:
        return None

    bones = options.get("bones", [])
    if not bones:
        return create_simple_rig(mesh_obj, options)

    height = bounds["height"]
    center = bounds["center"]
    base_z = bounds["min"].z

    armature = create_armature("Custom_Rig")
    enter_edit_mode(armature)

    for bone_def in bones:
        name = bone_def.get("name", "bone")
        # Positions are relative (0-1) and scaled to model size
        head_rel = bone_def.get("head", [0.5, 0.5, 0])
        tail_rel = bone_def.get("tail", [0.5, 0.5, 0.2])
        parent = bone_def.get("parent")
        connect = bone_def.get("connect", False)

        head = (
            center.x + (head_rel[0] - 0.5) * bounds["width"],
            center.y + (head_rel[1] - 0.5) * bounds["depth"],
            base_z + head_rel[2] * height
        )
        tail = (
            center.x + (tail_rel[0] - 0.5) * bounds["width"],
            center.y + (tail_rel[1] - 0.5) * bounds["depth"],
            base_z + tail_rel[2] * height
        )

        add_bone(armature, name, head, tail, parent_name=parent, connect=connect)

    exit_edit_mode()
    return armature


# ==================== RIGGING UTILITIES ====================

def add_basic_ik(armature):
    """Add basic IK constraints to the armature."""
    bpy.context.view_layer.objects.active = armature
    bpy.ops.object.mode_set(mode='POSE')

    # IK for arms
    for side in [".L", ".R"]:
        try:
            forearm = armature.pose.bones.get(f"forearm{side}")
            if forearm:
                ik = forearm.constraints.new('IK')
                ik.chain_count = 2
                ik.use_tail = True
        except:
            pass

        # IK for legs
        try:
            shin = armature.pose.bones.get(f"shin{side}")
            if shin:
                ik = shin.constraints.new('IK')
                ik.chain_count = 2
                ik.use_tail = True
        except:
            pass

    bpy.ops.object.mode_set(mode='OBJECT')


def parent_mesh_to_armature(mesh_obj, armature_obj, auto_weights=True):
    """Parent mesh to armature with automatic weights."""
    # Deselect all
    bpy.ops.object.select_all(action='DESELECT')

    # Select mesh then armature
    mesh_obj.select_set(True)
    armature_obj.select_set(True)
    bpy.context.view_layer.objects.active = armature_obj

    if auto_weights:
        try:
            bpy.ops.object.parent_set(type='ARMATURE_AUTO')
            print(f"Auto-weights applied to {mesh_obj.name}")
        except Exception as e:
            print(f"Auto-weights failed, using envelope: {e}")
            bpy.ops.object.parent_set(type='ARMATURE_ENVELOPE')
    else:
        bpy.ops.object.parent_set(type='ARMATURE_NAME')


def setup_camera_and_lighting():
    """Set up camera and lighting for the rigged model."""
    if not any(obj.type == 'CAMERA' for obj in bpy.data.objects):
        bpy.ops.object.camera_add(location=(7, -7, 5), rotation=(1.1, 0, 0.8))
        bpy.context.scene.camera = bpy.context.active_object

    if not any(obj.type == 'LIGHT' for obj in bpy.data.objects):
        bpy.ops.object.light_add(type='SUN', location=(5, 5, 10))
        bpy.context.active_object.data.energy = 3.0


# ==================== MAIN ====================

def main():
    """Main entry point for the auto-rig script."""
    argv = sys.argv
    try:
        arg_idx = argv.index("--") + 1
        args = argv[arg_idx:]
    except (ValueError, IndexError):
        print("ERROR: No arguments provided")
        print("Usage: blender --python blender_autorig.py -- <asset_path> <rig_type> [options_json]")
        return

    if len(args) < 2:
        print("ERROR: Missing arguments")
        return

    asset_path = Path(args[0])
    rig_type = args[1].lower()

    # Parse options
    options = {}
    if len(args) > 2:
        try:
            options = json.loads(args[2])
        except json.JSONDecodeError as e:
            print(f"Warning: Failed to parse options JSON: {e}")

    print(f"ComfyUI Auto-Rig: {asset_path} (type: {rig_type})")
    print(f"Options: {options}")

    if not asset_path.exists():
        print(f"ERROR: File not found: {asset_path}")
        return

    # Clear scene and import
    clear_scene()

    try:
        meshes = import_asset(str(asset_path))
        if not meshes:
            print("ERROR: No meshes found in imported file")
            return

        print(f"Imported {len(meshes)} mesh object(s)")

        # Use the largest mesh for rigging reference
        main_mesh = max(meshes, key=lambda m: get_mesh_bounds(m)["height"] if get_mesh_bounds(m) else 0)

        # Create rig based on type
        rig_creators = {
            "humanoid": create_humanoid_rig,
            "quadruped": create_quadruped_rig,
            "simple": create_simple_rig,
            "biped_simple": create_biped_simple_rig,
            "custom": create_custom_rig
        }

        creator = rig_creators.get(rig_type)
        if not creator:
            print(f"ERROR: Unknown rig type: {rig_type}")
            print(f"Available types: {list(rig_creators.keys())}")
            return

        armature = creator(main_mesh, options)

        if not armature:
            print("ERROR: Failed to create armature")
            return

        print(f"Created armature: {armature.name}")

        # Parent meshes to armature
        auto_weights = options.get("auto_weights", True)
        for mesh in meshes:
            parent_mesh_to_armature(mesh, armature, auto_weights)

        # Set up scene
        setup_camera_and_lighting()

        # Save if output path specified
        output_path = options.get("output_path")
        if output_path:
            bpy.ops.wm.save_as_mainfile(filepath=output_path)
            print(f"Saved to: {output_path}")

        print(f"Successfully rigged: {asset_path.name}")
        print(f"Rig type: {rig_type}")
        print(f"Armature: {armature.name}")
        print(f"Bones: {len(armature.data.bones)}")

    except Exception as e:
        print(f"ERROR: Auto-rig failed: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
